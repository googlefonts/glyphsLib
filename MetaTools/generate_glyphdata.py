# coding=UTF-8
#
# Copyright 2016 Google Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from __future__ import (print_function, division, absolute_import,
                        unicode_literals)
from fontTools.misc.py23 import *

import codecs
import fontTools.agl
import json
import urllib
import textwrap
import xml.etree.ElementTree as etree

from collections import namedtuple
from glyphsLib.glyphdata import get_glyph


# Data tables which we put into the generated Python file.
# See comments in generate_python_source() below for documentation.
GlyphData = namedtuple('GlyphData', [
    'PRODUCTION_NAMES',
    'IRREGULAR_UNICODE_STRINGS',
    'MISSING_UNICODE_STRINGS'
])


def fetch_url(url):
    stream = urllib.urlopen(url)
    content = stream.read()
    stream.close()
    return content


def fetch(filename):
    return fetch_url(
        "https://raw.githubusercontent.com/schriftgestalt/GlyphsInfo/master/"
        + filename)


def fetch_data_version():
    last_commit_info = fetch_url(
        "https://api.github.com/repos/schriftgestalt/GlyphsInfo/commits/master")
    return json.loads(last_commit_info)["sha"]


def fetch_all_glyphs():
    glyphs = {}
    for filename in ("GlyphData.xml", "GlyphData_Ideographs.xml"):
        for glyph in etree.fromstring(fetch(filename)).findall("glyph"):
            glyphName = glyph.attrib["name"]
            assert glyphName not in glyphs, "multiple entries for " + glyphName
            glyphs[glyphName] = glyph.attrib
    return glyphs


def build_data(glyphs):
    prodnames = {}
    irregular_unicode_strings = {}
    missing_unicode_strings = set()
    for name, glyph in glyphs.items():
        prodname = glyph.get("production", name)
        if prodname != name:
            prodnames[name] = prodname
        inferred_unistr = fontTools.agl.toUnicode(prodname)
        unistr = glyph.get("unicode")
        unistr = unichr(int(unistr, 16)) if unistr else None
        if unistr is None:
            missing_unicode_strings.add(name)
        elif unistr != inferred_unistr:
            irregular_unicode_strings[name] = unistr
    return GlyphData(prodnames,
                     irregular_unicode_strings,
                     missing_unicode_strings)


def test_data(glyphs, data):
    """Runs checks on the generated GlyphData

    Makes sure that the implementation of glyphsLib.glyphdata.get_glyph(),
    if it were to work on the generated GlyphData, will produce the exact
    same results as the original data files.
    """
    for _, glyph in sorted(glyphs.items()):
        name = glyph["name"]
        prod = glyph.get("production", name)
        unicode = glyph.get("unicode")
        unicode = unichr(int(unicode, 16)) if unicode else None
        g = get_glyph(name, data=data)
        assert name == g.name, (name, g.name)
        assert prod == g.production_name, (name, prod, g.production_name)
        assert unicode == g.unicode, (name, unicode, g.unicode)


def generate_python_source(data, out):
    out.write(
        "# -*- coding: utf-8 -*-\n"
        "#\n"
        "# Please do not manually edit this file.\n"
        "#\n"
        "# It has been generated by MetaTools/generate_glyphdata.py using\n"
        "# upstream data from https://github.com/schriftgestalt/GlyphsInfo/\n"
        "# taken at commit hash %s.\n"
        "#\n"
        % fetch_data_version())

    for paragraph in fetch("LICENSE").strip().split("\n\n"):
        out.write("#\n")
        for line in textwrap.wrap(paragraph):
            out.write("# ")
            out.write(line)
            out.write("\n")

    out.write("\nfrom __future__ import unicode_literals\n\n\n")
    out.write(
        "# Glyphs for which Glyphs.app uses production names that do not\n"
        "# comply with the Adobe Glyph List specification.\n")
    out.write("PRODUCTION_NAMES = {\n")
    for key, value in sorted(data.PRODUCTION_NAMES.items()):
        out.write('\t"%s":"%s",\n' % (key, value))
    out.write("}\n\n")

    out.write(
        "# Glyphs for which Glyphs.app has a different Unicode string\n"
        "# than the string we would generate from the production name.\n")
    out.write("IRREGULAR_UNICODE_STRINGS = {\n")
    for key, value in sorted(data.IRREGULAR_UNICODE_STRINGS.items()):
        out.write('\t"%s":"%s",\n' % (key, value.encode("unicode-escape")))
    out.write("}\n\n")

    out.write(
        "# Glyphs for which Glyphs.app has no Unicode string.\n"
        "# For almost all these glyphs, one could derive a Unicode string\n"
        "# from the production glyph name, but Glyphs.app still has none\n"
        "# in its data. Many of these cases seem to be bugs in GlyphsData,\n"
        "# but we need to be compatible with Glyphs.\n")
    out.write("MISSING_UNICODE_STRINGS = {\n")
    for name in sorted(data.MISSING_UNICODE_STRINGS):
        out.write('\t"%s",\n' % name)
    out.write("}\n")


if __name__ == "__main__":
    outpath = "Lib/glyphsLib/glyphdata_generated.py"
    glyphs = fetch_all_glyphs()
    data = build_data(glyphs)
    test_data(glyphs, data)
    with codecs.open(outpath, "w", "utf-8") as out:
        generate_python_source(data, out)
