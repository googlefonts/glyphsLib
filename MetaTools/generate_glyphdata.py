# coding=UTF-8
#
# Copyright 2016 Google Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from __future__ import (print_function, division, absolute_import,
                        unicode_literals)

import io
import json
import textwrap

from glyphsLib.util import build_data, test_data, fetch, fetch_url, fetch_all_glyphs


def fetch_data_version():
    last_commit_info = fetch_url(
        "https://api.github.com/repos/schriftgestalt/GlyphsInfo/commits/master")
    return json.loads(last_commit_info)["sha"]


def nonesorter(a):
    # Python 2 sorts None before any string (even empty string), while
    # Python 3 raises a TypeError when attempting to compare NoneType with str.
    # Here we emulate python 2 and return "" when an item to be sorted is None
    if isinstance(a, tuple):
        return tuple(nonesorter(e) for e in a)
    return "" if a is None else a


def generate_python_source(glyphs, out):
    data = build_data(glyphs)
    test_data(glyphs, data)

    out.write(
        "# -*- coding: utf-8 -*-\n"
        "#\n"
        "# Please do not manually edit this file.\n"
        "#\n"
        "# It has been generated by MetaTools/generate_glyphdata.py using\n"
        "# upstream data from https://github.com/schriftgestalt/GlyphsInfo/\n"
        "# taken at commit hash %s.\n"
        "#\n"
        % fetch_data_version())

    for paragraph in fetch("LICENSE").strip().split("\n\n"):
        out.write("#\n")
        for line in textwrap.wrap(paragraph):
            out.write("# ")
            out.write(line)
            out.write("\n")

    out.write("\nfrom __future__ import unicode_literals\n\n\n")
    out.write(
        "# Glyphs for which Glyphs.app uses production names that do not\n"
        "# comply with the Adobe Glyph List specification.\n")
    out.write("PRODUCTION_NAMES = {\n")
    for key, value in sorted(data.PRODUCTION_NAMES.items()):
        out.write('\t"%s":"%s",\n' % (key, value))
    out.write("}\n\n")

    out.write(
        "# Glyphs for which Glyphs.app has a different Unicode string\n"
        "# than the string we would generate from the production name.\n")
    out.write("IRREGULAR_UNICODE_STRINGS = {\n")
    for key, value in sorted(data.IRREGULAR_UNICODE_STRINGS.items()):
        value_repr = value.encode("unicode-escape").decode('ascii')
        out.write('\t"%s":"%s",\n' % (key, value_repr))
    out.write("}\n\n")

    out.write(
        "# Glyphs for which Glyphs.app has no Unicode string.\n"
        "# For almost all these glyphs, one could derive a Unicode string\n"
        "# from the production glyph name, but Glyphs.app still has none\n"
        "# in its data. Many of these cases seem to be bugs in GlyphsData,\n"
        "# but we need to be compatible with Glyphs.\n")
    out.write("MISSING_UNICODE_STRINGS = {\n")
    for name in sorted(data.MISSING_UNICODE_STRINGS):
        out.write('\t"%s",\n' % name)
    out.write("}\n\n")

    out.write(
        "# From the first character of the Unicode string of a glyph,\n"
        "# one can compute the Unicode category. This Unicode category\n"
        "# can frequently be mapped to the Glyphs category and subCategory.\n"
        "DEFAULT_CATEGORIES = {\n")
    for ucat, glyphsCat in sorted(
            data.DEFAULT_CATEGORIES.items(), key=nonesorter):
        out.write('\t%s: %s,\n' %
                  ('"%s"' % ucat if ucat else 'None', glyphsCat))
    out.write("}\n\n")

    out.write(
        "# However, to some glyphs, Glyphs.app assigns a different category\n"
        "# or sub-category than Unicode. The following table contains these\n"
        "# exceptions.\n"
        "IRREGULAR_CATEGORIES = {\n")
    for glyphName, glyphsCat in sorted(
            data.IRREGULAR_CATEGORIES.items(), key=nonesorter):
        out.write('\t"%s": %s,\n' % (glyphName, glyphsCat))
    out.write("}\n\n")

    out.write(
        "DEFAULT_GLYPH_DICT = %s\n\n" % glyphs
    )

    
if __name__ == "__main__":
    outpath = "Lib/glyphsLib/glyphdata_generated.py"
    xml_paths = (fetch(filename) for filename in ("GlyphData.xml", "GlyphData_Ideographs.xml"))
    glyphs = fetch_all_glyphs(paths=xml_paths)
    with io.open(outpath, "w", encoding="utf-8") as out:
        generate_python_source(glyphs, out)